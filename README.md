# banner-service-api
[![build and test](https://github.com/nikitads9/banner-service-api/actions/workflows/build.yml/badge.svg)](https://github.com/nikitads9/banner-service-api/actions/workflows/build.yml)
[![linters](https://github.com/nikitads9/banner-service-api/actions/workflows/linter.yml/badge.svg)](https://github.com/nikitads9/banner-service-api/actions/workflows/linter.yml)
[![codecov](https://codecov.io/gh/nikitads9/banner-service-api/graph/badge.svg?token=FGLI9UL7CS)](https://codecov.io/gh/nikitads9/banner-service-api) <br />
Avito backend task 2024.

## Сервис баннеров

В Авито есть большое количество неоднородного контента, для которого необходимо иметь единую систему управления. В 
частности, необходимо показывать разный контент пользователям в зависимости от их принадлежности к какой-либо группе. 
Данный контент мы будем предоставлять с помощью баннеров.

## Описание задачи
Необходимо реализовать сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и 
тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.

## Как решалась задача

- Задача выполнена на языке `Go` версии 1.22.1. Проект построен по принципу `model`, `view`, `controller` .
- Для генерирования валидаторов, прототипов хэндлеров был использован генератор [ogen-go](https://github.com/ogen-go/ogen), который создает основные схемы для взаимодействия с клиентом, генерирует сервер, базовые middleware для сбора метрик и трейсов в формате [open telemetry](https://github.com/open-telemetry). Протокол OTLP позволяет централизованно собирать телеметрию, обрабатывать под нужный формат и передавать получателям, таким как LogStash, Fluentd, Prometheus, Jaeger, Elasticsearch. Я выбрал `ogen-go`, поскольку привык к удобной генерации кода для создания бэкенд-интерфейсов на опыте с связкой `grpc` + `protobuf`, где есть удобная утилита `protogen`.
- Логирование было реализовано с помощью slog, формат логов выбирается в зависимости от обозначенной в конфиге или в переменной окружения среды запуска сервера: local, dev, prod. В двух последних случаях логи выводятся в stdout в формате JSON.
- Написаны middleware для логирования и авторизации по JWT-токену.
- В качестве основной среды для запуска решения предполагается `Docker` контейнеры. Описана конфигурация docker-compose для контейнеров с резидентной кэш базой данных `Redis`, реляционной СУБД `PostgreSQL`, коллектора телеметрии `otelcol`, платформы для трейсинга `Jaeger`, NoSQL time series DB `Prometheus`. Для сборки образа серверного приложения написан multi-stage `Dockerfile`, в котором сборка производится на основе образа `golang:1.22-alpine`, а запускаться сервер будет в `alpine:latest`.
- Драйвер для подключения и запросов в PostgreSQL: [pgx](https://github.com/jackc/pgx) и [pgxpool](https://github.com/jackc/pgx/tree/master/pgxpool).
- Для хранения кэшаиспользуется `Redis` с SDK [go-redis](https://github.com/redis/go-redis).
- Для удобного развертывания были написаны скрипты `Makefile`, позволяющие накатывать и откатывать миграции, собирать бинарники, производить тестирование и генерировать моки (`mockgen`) и серверный код (`ogen-go`).
- Линтер-проверки, проверка на прохождение тестов и проверка на build выполнены в `Github Actions` с помощью пайплайнов build и linter.
<br /> <br /> <br />
<picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://github.com/nikitads9/banner-service-api/assets/project-design-dark.png">
    <img alt="project design" src="https://github.com/nikitads9/banner-service-api/assets/project-design-dark.png">
</picture>

## Пункты задания

1. ✔ Используйте этот [API](https://github.com/avito-tech/backend-trainee-assignment-2024/blob/main/api.yaml).
   * Данная документация была использована при генерации `ogen-go`. В нее были внесены изменения (для того, чтобы сгенерированный сервер функционировал так как нужно + некоторые изменения были нужны, чтобы удовлетворить требования стандарта Open API 3.0). Окончательная версия документации лежит в директории `docs` и проверена в Insomnia (синтаксических ошибок open api не выявлено). <br /> 
   <details>
    <summary> 
        Изменения:
    </summary>
   - Во всех запросах, содержащих поле тела content, убран object, чтобы ogen сгенерировал структуру с полем jx.Raw, которая является аналогом json.RawMessage.
   - В запросах и некоторых ответах обозначил required поля, чтобы `ogen-go` генерировал ненуллабельные поля в структурах.
   - Добавил формат ***int64*** для того, чтобы API не использовал неопределенный (зависящий от архитектуры процессора клиента) тип ***int***.
   - Добавил поля необходимые для удовлетворения требований к синтаксису OAS. Такие поля как описание операций, теги, глобальные теги, контактные данные.
   - Добавил securitySchema конфигурацию, для того, чтобы четко сформулировать механизм получения токенов.
   </details>
2. ✔ Тегов и фичей небольшое количество (до 1000), RPS — 1k, SLI времени ответа — 50 мс, SLI успешности ответа — 99.99%
   * В качестве инфраструктуры наблюдаемости использована связка Prometheus + Jaeger. Первый служит хранилищщем метрик, второй нужен для трейсинга запросов и мониторинга (к сожалению не в риалтайм, приходится прожимать F5). За выполнением SLI можно следить в Jaeger.
3. ✔ Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и админский.
   Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные 
   действия могут выполняться только с помощью админского токена. 
   * Написан middleware для проверки токенов, токены админов начинаются с префикса AdminToken, а у юзеров - UserToken.
4. ✘ Реализуйте интеграционный или E2E-тест на сценарий получения баннера.
   * В процессе.
5. ✔ Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую актуальную информацию.
   В ином случае допускается передача информации, которая была актуальна 5 минут назад.
   * Для пользовательского метода получения содержимого баннера реализовано кэширование по классической схеме. При наличии флага ***use_last_revision*** в запросе, кэш не используется (однако полученное значение все равно кэшируется), запрос отправляется в базу данных. Если этого флага нет или он обозначен как ***false***, то значение сначала получается из кэша.
6. ✔ Баннеры могут быть временно выключены. Если баннер выключен, то обычные пользователи не должны его получать, 
   при этом админы должны иметь к нему доступ.
    * При попытке получения баннера пользователем SELECT запрос в БД проверяет баннер на значение флага ***is_active***.

## Пункты дополнительного задания

1. ✔ Адаптировать систему для значительного увеличения количества тегов и фичей, при котором допускается 
   увеличение времени исполнения по редко запрашиваемым тегам и фичам. 
   * Помимо автоматически созданных индексов на первичные ключи, были созданны индексы btree на внешние ключи ***feature_id*** и ***tag_id***.
2. ✘ Провести нагрузочное тестирование полученного решения и приложить результаты тестирования к решению.
   * В процессе
3. ✘ Иногда получается так, что необходимо вернуться к одной из трех предыдущих версий баннера в связи с 
   найденной ошибкой в логике, тексте и т.д.  Измените API таким образом, чтобы можно было просмотреть существующие 
   версии баннера и выбрать подходящую версию.
   * Для данного решения представляется оптимальным использовать триггеры на insert/update с удалением третьей с конца строки выбранной из таблицы версий баннеров. Не успел реализовать, сижу над дипломом :(
4. ✘ Добавить метод удаления баннеров по фиче или тегу, время ответа которого не должно превышать 100 мс, 
   независимо от количества баннеров.  В связи с небольшим временем ответа метода, рекомендуется ознакомиться 
   с механизмом выполнения отложенных действий.
5. ✘ Реализовать интеграционное или E2E-тестирование для остальных сценариев
   * В процессе
6. ✔ Описать конфигурацию линтера
   * Настроен пайплайн golangci-lint в файле [linter.yml](.github/workflows/linter.yml).